{"version":3,"file":"xml.js","sources":["../../src/ol/xml.js"],"sourcesContent":["/**\r\n * @module ol/xml\r\n */\r\nimport {extend} from './array.js';\r\n\r\n\r\n/**\r\n * When using {@link module:ol/xml~makeChildAppender} or\r\n * {@link module:ol/xml~makeSimpleNodeFactory}, the top `objectStack` item needs\r\n * to have this structure.\r\n * @typedef {Object} NodeStackItem\r\n * @property {Node} node\r\n */\r\n\r\n\r\n/**\r\n * @typedef {function(Node, Array.<*>)} Parser\r\n */\r\n\r\n\r\n/**\r\n * @typedef {function(Node, *, Array.<*>)} Serializer\r\n */\r\n\r\n\r\n/**\r\n * This document should be used when creating nodes for XML serializations. This\r\n * document is also used by {@link module:ol/xml~createElementNS}\r\n * @const\r\n * @type {Document}\r\n */\r\nexport const DOCUMENT = document.implementation.createDocument('', '', null);\r\n\r\n\r\n/**\r\n * @type {string}\r\n */\r\nexport const XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\r\n\r\n\r\n/**\r\n * @param {string} namespaceURI Namespace URI.\r\n * @param {string} qualifiedName Qualified name.\r\n * @return {Node} Node.\r\n */\r\nexport function createElementNS(namespaceURI, qualifiedName) {\r\n  return DOCUMENT.createElementNS(namespaceURI, qualifiedName);\r\n}\r\n\r\n\r\n/**\r\n * Recursively grab all text content of child nodes into a single string.\r\n * @param {Node} node Node.\r\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\r\n * breaks.\r\n * @return {string} All text content.\r\n * @api\r\n */\r\nexport function getAllTextContent(node, normalizeWhitespace) {\r\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\r\n}\r\n\r\n\r\n/**\r\n * Recursively grab all text content of child nodes into a single string.\r\n * @param {Node} node Node.\r\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\r\n * breaks.\r\n * @param {Array.<string>} accumulator Accumulator.\r\n * @private\r\n * @return {Array.<string>} Accumulator.\r\n */\r\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\r\n  if (node.nodeType == Node.CDATA_SECTION_NODE ||\r\n      node.nodeType == Node.TEXT_NODE) {\r\n    if (normalizeWhitespace) {\r\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\r\n    } else {\r\n      accumulator.push(node.nodeValue);\r\n    }\r\n  } else {\r\n    let n;\r\n    for (n = node.firstChild; n; n = n.nextSibling) {\r\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\r\n    }\r\n  }\r\n  return accumulator;\r\n}\r\n\r\n\r\n/**\r\n * @param {?} value Value.\r\n * @return {boolean} Is document.\r\n */\r\nexport function isDocument(value) {\r\n  return value instanceof Document;\r\n}\r\n\r\n\r\n/**\r\n * @param {?} value Value.\r\n * @return {boolean} Is node.\r\n */\r\nexport function isNode(value) {\r\n  return value instanceof Node;\r\n}\r\n\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {?string} namespaceURI Namespace URI.\r\n * @param {string} name Attribute name.\r\n * @return {string} Value\r\n */\r\nexport function getAttributeNS(node, namespaceURI, name) {\r\n  return node.getAttributeNS(namespaceURI, name) || '';\r\n}\r\n\r\n\r\n/**\r\n * Parse an XML string to an XML Document.\r\n * @param {string} xml XML.\r\n * @return {Document} Document.\r\n * @api\r\n */\r\nexport function parse(xml) {\r\n  return new DOMParser().parseFromString(xml, 'application/xml');\r\n}\r\n\r\n\r\n/**\r\n * Make an array extender function for extending the array at the top of the\r\n * object stack.\r\n * @param {function(this: T, Node, Array.<*>): (Array.<*>|undefined)}\r\n *     valueReader Value reader.\r\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\r\n * @return {module:ol/xml~Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeArrayExtender(valueReader, opt_this) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array.<*>} objectStack Object stack.\r\n     */\r\n    function(node, objectStack) {\r\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const array = /** @type {Array.<*>} */ (objectStack[objectStack.length - 1]);\r\n        extend(array, value);\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * Make an array pusher function for pushing to the array at the top of the\r\n * object stack.\r\n * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\r\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\r\n * @return {module:ol/xml~Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeArrayPusher(valueReader, opt_this) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array.<*>} objectStack Object stack.\r\n     */\r\n    function(node, objectStack) {\r\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const array = /** @type {Array.<*>} */ (objectStack[objectStack.length - 1]);\r\n        array.push(value);\r\n      }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Make an object stack replacer function for replacing the object at the\r\n * top of the stack.\r\n * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\r\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\r\n * @return {module:ol/xml~Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeReplacer(valueReader, opt_this) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array.<*>} objectStack Object stack.\r\n     */\r\n    function(node, objectStack) {\r\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\r\n      if (value !== undefined) {\r\n        objectStack[objectStack.length - 1] = value;\r\n      }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Make an object property pusher function for adding a property to the\r\n * object at the top of the stack.\r\n * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\r\n * @param {string=} opt_property Property.\r\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\r\n * @return {module:ol/xml~Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array.<*>} objectStack Object stack.\r\n     */\r\n    function(node, objectStack) {\r\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\r\n        const property = opt_property !== undefined ? opt_property : node.localName;\r\n        let array;\r\n        if (property in object) {\r\n          array = object[property];\r\n        } else {\r\n          array = object[property] = [];\r\n        }\r\n        array.push(value);\r\n      }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Make an object property setter function.\r\n * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.\r\n * @param {string=} opt_property Property.\r\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\r\n * @return {module:ol/xml~Parser} Parser.\r\n * @template T\r\n */\r\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\r\n  return (\r\n    /**\r\n     * @param {Node} node Node.\r\n     * @param {Array.<*>} objectStack Object stack.\r\n     */\r\n    function(node, objectStack) {\r\n      const value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\r\n      if (value !== undefined) {\r\n        const object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\r\n        const property = opt_property !== undefined ? opt_property : node.localName;\r\n        object[property] = value;\r\n      }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Create a serializer that appends nodes written by its `nodeWriter` to its\r\n * designated parent. The parent is the `node` of the\r\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\r\n * @param {function(this: T, Node, V, Array.<*>)}\r\n *     nodeWriter Node writer.\r\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\r\n * @return {module:ol/xml~Serializer} Serializer.\r\n * @template T, V\r\n */\r\nexport function makeChildAppender(nodeWriter, opt_this) {\r\n  return function(node, value, objectStack) {\r\n    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\r\n    const parent = /** @type {module:ol/xml~NodeStackItem} */ (objectStack[objectStack.length - 1]);\r\n    const parentNode = parent.node;\r\n    parentNode.appendChild(node);\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Create a serializer that calls the provided `nodeWriter` from\r\n * {@link module:ol/xml~serialize}. This can be used by the parent writer to have the\r\n * 'nodeWriter' called with an array of values when the `nodeWriter` was\r\n * designed to serialize a single item. An example would be a LineString\r\n * geometry writer, which could be reused for writing MultiLineString\r\n * geometries.\r\n * @param {function(this: T, Node, V, Array.<*>)}\r\n *     nodeWriter Node writer.\r\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\r\n * @return {module:ol/xml~Serializer} Serializer.\r\n * @template T, V\r\n */\r\nexport function makeArraySerializer(nodeWriter, opt_this) {\r\n  let serializersNS, nodeFactory;\r\n  return function(node, value, objectStack) {\r\n    if (serializersNS === undefined) {\r\n      serializersNS = {};\r\n      const serializers = {};\r\n      serializers[node.localName] = nodeWriter;\r\n      serializersNS[node.namespaceURI] = serializers;\r\n      nodeFactory = makeSimpleNodeFactory(node.localName);\r\n    }\r\n    serialize(serializersNS, nodeFactory, value, objectStack);\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Create a node factory which can use the `opt_keys` passed to\r\n * {@link module:ol/xml~serialize} or {@link module:ol/xml~pushSerializeAndPop} as node names,\r\n * or a fixed node name. The namespace of the created nodes can either be fixed,\r\n * or the parent namespace will be used.\r\n * @param {string=} opt_nodeName Fixed node name which will be used for all\r\n *     created nodes. If not provided, the 3rd argument to the resulting node\r\n *     factory needs to be provided and will be the nodeName.\r\n * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for\r\n *     all created nodes. If not provided, the namespace of the parent node will\r\n *     be used.\r\n * @return {function(*, Array.<*>, string=): (Node|undefined)} Node factory.\r\n */\r\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\r\n  const fixedNodeName = opt_nodeName;\r\n  return (\r\n    /**\r\n     * @param {*} value Value.\r\n     * @param {Array.<*>} objectStack Object stack.\r\n     * @param {string=} opt_nodeName Node name.\r\n     * @return {Node} Node.\r\n     */\r\n    function(value, objectStack, opt_nodeName) {\r\n      const context = /** @type {module:ol/xml~NodeStackItem} */ (objectStack[objectStack.length - 1]);\r\n      const node = context.node;\r\n      let nodeName = fixedNodeName;\r\n      if (nodeName === undefined) {\r\n        nodeName = opt_nodeName;\r\n      }\r\n\r\n      const namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\r\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\r\n    }\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * A node factory that creates a node using the parent's `namespaceURI` and the\r\n * `nodeName` passed by {@link module:ol/xml~serialize} or\r\n * {@link module:ol/xml~pushSerializeAndPop} to the node factory.\r\n * @const\r\n * @type {function(*, Array.<*>, string=): (Node|undefined)}\r\n */\r\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\r\n\r\n\r\n/**\r\n * Create an array of `values` to be used with {@link module:ol/xml~serialize} or\r\n * {@link module:ol/xml~pushSerializeAndPop}, where `orderedKeys` has to be provided as\r\n * `opt_key` argument.\r\n * @param {Object.<string, V>} object Key-value pairs for the sequence. Keys can\r\n *     be a subset of the `orderedKeys`.\r\n * @param {Array.<string>} orderedKeys Keys in the order of the sequence.\r\n * @return {Array.<V>} Values in the order of the sequence. The resulting array\r\n *     has the same length as the `orderedKeys` array. Values that are not\r\n *     present in `object` will be `undefined` in the resulting array.\r\n * @template V\r\n */\r\nexport function makeSequence(object, orderedKeys) {\r\n  const length = orderedKeys.length;\r\n  const sequence = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    sequence[i] = object[orderedKeys[i]];\r\n  }\r\n  return sequence;\r\n}\r\n\r\n\r\n/**\r\n * Create a namespaced structure, using the same values for each namespace.\r\n * This can be used as a starting point for versioned parsers, when only a few\r\n * values are version specific.\r\n * @param {Array.<string>} namespaceURIs Namespace URIs.\r\n * @param {T} structure Structure.\r\n * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.\r\n * @return {Object.<string, T>} Namespaced structure.\r\n * @template T\r\n */\r\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\r\n  /**\r\n   * @type {Object.<string, T>}\r\n   */\r\n  const structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\r\n  let i, ii;\r\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\r\n    structureNS[namespaceURIs[i]] = structure;\r\n  }\r\n  return structureNS;\r\n}\r\n\r\n\r\n/**\r\n * Parse a node using the parsers and object stack.\r\n * @param {Object.<string, Object.<string, module:ol/xml~Parser>>} parsersNS\r\n *     Parsers by namespace.\r\n * @param {Node} node Node.\r\n * @param {Array.<*>} objectStack Object stack.\r\n * @param {*=} opt_this The object to use as `this`.\r\n */\r\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\r\n  let n;\r\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n    const parsers = parsersNS[n.namespaceURI];\r\n    if (parsers !== undefined) {\r\n      const parser = parsers[n.localName];\r\n      if (parser !== undefined) {\r\n        parser.call(opt_this, n, objectStack);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Push an object on top of the stack, parse and return the popped object.\r\n * @param {T} object Object.\r\n * @param {Object.<string, Object.<string, module:ol/xml~Parser>>} parsersNS\r\n *     Parsers by namespace.\r\n * @param {Node} node Node.\r\n * @param {Array.<*>} objectStack Object stack.\r\n * @param {*=} opt_this The object to use as `this`.\r\n * @return {T} Object.\r\n * @template T\r\n */\r\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\r\n  objectStack.push(object);\r\n  parseNode(parsersNS, node, objectStack, opt_this);\r\n  return /** @type {T} */ (objectStack.pop());\r\n}\r\n\r\n\r\n/**\r\n * Walk through an array of `values` and call a serializer for each value.\r\n * @param {Object.<string, Object.<string, module:ol/xml~Serializer>>} serializersNS\r\n *     Namespaced serializers.\r\n * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory\r\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\r\n *     will be used to choose a node writer from `serializersNS`. This\r\n *     separation allows us to decide what kind of node to create, depending on\r\n *     the value we want to serialize. An example for this would be different\r\n *     geometry writers based on the geometry type.\r\n * @param {Array.<*>} values Values to serialize. An example would be an array\r\n *     of {@link module:ol/Feature~Feature} instances.\r\n * @param {Array.<*>} objectStack Node stack.\r\n * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the\r\n *     `nodeFactory`. This is used for serializing object literals where the\r\n *     node name relates to the property key. The array length of `opt_keys` has\r\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\r\n *     determines the order of the sequence.\r\n * @param {T=} opt_this The object to use as `this` for the node factory and\r\n *     serializers.\r\n * @template T\r\n */\r\nexport function serialize(\r\n  serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\r\n  const length = (opt_keys !== undefined ? opt_keys : values).length;\r\n  let value, node;\r\n  for (let i = 0; i < length; ++i) {\r\n    value = values[i];\r\n    if (value !== undefined) {\r\n      node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack,\r\n        opt_keys !== undefined ? opt_keys[i] : undefined);\r\n      if (node !== undefined) {\r\n        serializersNS[node.namespaceURI][node.localName]\r\n          .call(opt_this, node, value, objectStack);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @param {O} object Object.\r\n * @param {Object.<string, Object.<string, module:ol/xml~Serializer>>} serializersNS\r\n *     Namespaced serializers.\r\n * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory\r\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\r\n *     will be used to choose a node writer from `serializersNS`. This\r\n *     separation allows us to decide what kind of node to create, depending on\r\n *     the value we want to serialize. An example for this would be different\r\n *     geometry writers based on the geometry type.\r\n * @param {Array.<*>} values Values to serialize. An example would be an array\r\n *     of {@link module:ol/Feature~Feature} instances.\r\n * @param {Array.<*>} objectStack Node stack.\r\n * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the\r\n *     `nodeFactory`. This is used for serializing object literals where the\r\n *     node name relates to the property key. The array length of `opt_keys` has\r\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\r\n *     determines the order of the sequence.\r\n * @param {T=} opt_this The object to use as `this` for the node factory and\r\n *     serializers.\r\n * @return {O|undefined} Object.\r\n * @template O, T\r\n */\r\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\r\n  objectStack.push(object);\r\n  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\r\n  return /** @type {O|undefined} */ (objectStack.pop());\r\n}\r\n"],"names":["const","let","this"],"mappings":"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"}