{"version":3,"file":"VectorTile.js","sources":["../../../src/ol/source/VectorTile.js"],"sourcesContent":["/**\r\n * @module ol/source/VectorTile\r\n */\r\n\r\nimport TileState from '../TileState.js';\r\nimport VectorImageTile, {defaultLoadFunction} from '../VectorImageTile.js';\r\nimport Tile from '../VectorTile.js';\r\nimport {toSize} from '../size.js';\r\nimport UrlTile from '../source/UrlTile.js';\r\nimport {getKeyZXY} from '../tilecoord.js';\r\nimport {createXYZ, extentFromProjection, createForProjection} from '../tilegrid.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\r\n * @property {number} [cacheSize=128] Cache size.\r\n * @property {module:ol/format/Feature} [format] Feature format for tiles. Used and required by the default.\r\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\r\n * to `false` (e.g. for sources with polygons that represent administrative\r\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\r\n * stroke operations.\r\n * @property {module:ol/proj~ProjectionLike} projection Projection.\r\n * @property {module:ol/source/State} [state] Source state.\r\n * @property {module:ol/VectorTile~TileClass} [tileClass] Class used to instantiate image tiles.\r\n * Default is {@link module:ol/VectorTile}.\r\n * @property {number} [maxZoom=22] Optional max zoom level.\r\n * @property {number} [minZoom] Optional min zoom level.\r\n * @property {number|module:ol/size~Size} [tileSize=512] Optional tile size.\r\n * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.\r\n * @property {module:ol/Tile~LoadFunction} [tileLoadFunction]\r\n * Optional function to load a tile given a URL. Could look like this:\r\n * ```js\r\n * function(tile, url) {\r\n *   tile.setLoader(function() {\r\n *     var data = // ... fetch data\r\n *     var format = tile.getFormat();\r\n *     tile.setProjection(format.readProjection(data));\r\n *     tile.setFeatures(format.readFeatures(data, {\r\n *       // featureProjection is not required for ol/format/MVT\r\n *       featureProjection: map.getView().getProjection()\r\n *     }));\r\n *     // the line below is only required for ol/format/MVT\r\n *     tile.setExtent(format.getLastExtent());\r\n *   };\r\n * });\r\n * ```\r\n * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\r\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\r\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\r\n * used instead of defining each one separately in the `urls` option.\r\n * @property {number} [transition] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {Array.<string>} [urls] An array of URL templates.\r\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\r\n * When set to `false`, only one world\r\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\r\n * render multiple worlds.\r\n */\r\n\r\n\r\n/**\r\n * @classdesc\r\n * Class for layer sources providing vector data divided into a tile grid, to be\r\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\r\n * with vector features from the server, it is not meant for feature editing.\r\n * Features are optimized for rendering, their geometries are clipped at or near\r\n * tile boundaries and simplified for a view resolution. See\r\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\r\n * editing.\r\n *\r\n * @fires module:ol/source/Tile~TileSourceEvent\r\n * @api\r\n */\r\nclass VectorTile extends UrlTile {\r\n  /**\r\n   * @param {module:ol/source/VectorTile~Options=} options Vector tile options.\r\n   */\r\n  constructor(options) {\r\n    const projection = options.projection || 'EPSG:3857';\r\n\r\n    const extent = options.extent || extentFromProjection(projection);\r\n\r\n    const tileGrid = options.tileGrid || createXYZ({\r\n      extent: extent,\r\n      maxZoom: options.maxZoom || 22,\r\n      minZoom: options.minZoom,\r\n      tileSize: options.tileSize || 512\r\n    });\r\n\r\n    super({\r\n      attributions: options.attributions,\r\n      cacheSize: options.cacheSize !== undefined ? options.cacheSize : 128,\r\n      extent: extent,\r\n      opaque: false,\r\n      projection: projection,\r\n      state: options.state,\r\n      tileGrid: tileGrid,\r\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\r\n      tileUrlFunction: options.tileUrlFunction,\r\n      url: options.url,\r\n      urls: options.urls,\r\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\r\n      transition: options.transition\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {module:ol/format/Feature}\r\n     */\r\n    this.format_ = options.format ? options.format : null;\r\n\r\n    /**\r\n       * @private\r\n       * @type {Object.<string, module:ol/VectorTile>}\r\n       */\r\n    this.sourceTiles_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\r\n\r\n    /**\r\n       * @protected\r\n       * @type {function(new: module:ol/VectorTile, module:ol/tilecoord~TileCoord, module:ol/TileState, string,\r\n       *        module:ol/format/Feature, module:ol/Tile~LoadFunction)}\r\n       */\r\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object.<string, module:ol/tilegrid/TileGrid>}\r\n     */\r\n    this.tileGrids_ = {};\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @return {boolean} The source can have overlapping geometries.\r\n */\r\nVectorTile.prototype.getOverlaps = function() {\r\n  return this.overlaps_;\r\n};\r\n\r\n/**\r\n * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\r\n * @api\r\n */\r\nVectorTile.prototype.clear = function() {\r\n  this.tileCache.clear();\r\n  this.sourceTiles_ = {};\r\n};\r\n\r\n/**\r\n * @inheritDoc\r\n */\r\nVectorTile.prototype.getTile = function(z, x, y, pixelRatio, projection) {\r\n  const tileCoordKey = getKeyZXY(z, x, y);\r\n  if (this.tileCache.containsKey(tileCoordKey)) {\r\n    return (\r\n      /** @type {!module:ol/Tile} */ (this.tileCache.get(tileCoordKey))\r\n    );\r\n  } else {\r\n    const tileCoord = [z, x, y];\r\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\r\n      tileCoord, projection);\r\n    const tile = new VectorImageTile(\r\n      tileCoord,\r\n      urlTileCoord !== null ? TileState.IDLE : TileState.EMPTY,\r\n      this.getRevision(),\r\n      this.format_, this.tileLoadFunction, urlTileCoord, this.tileUrlFunction,\r\n      this.tileGrid, this.getTileGridForProjection(projection),\r\n      this.sourceTiles_, pixelRatio, projection, this.tileClass,\r\n      this.handleTileChange.bind(this), tileCoord[0]);\r\n\r\n    this.tileCache.set(tileCoordKey, tile);\r\n    return tile;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @inheritDoc\r\n */\r\nVectorTile.prototype.getTileGridForProjection = function(projection) {\r\n  const code = projection.getCode();\r\n  let tileGrid = this.tileGrids_[code];\r\n  if (!tileGrid) {\r\n    // A tile grid that matches the tile size of the source tile grid is more\r\n    // likely to have 1:1 relationships between source tiles and rendered tiles.\r\n    const sourceTileGrid = this.tileGrid;\r\n    tileGrid = this.tileGrids_[code] = createForProjection(projection, undefined,\r\n      sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\r\n  }\r\n  return tileGrid;\r\n};\r\n\r\n\r\n/**\r\n * @inheritDoc\r\n */\r\nVectorTile.prototype.getTilePixelRatio = function(pixelRatio) {\r\n  return pixelRatio;\r\n};\r\n\r\n\r\n/**\r\n * @inheritDoc\r\n */\r\nVectorTile.prototype.getTilePixelSize = function(z, pixelRatio, projection) {\r\n  const tileGrid = this.getTileGridForProjection(projection);\r\n  const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\r\n  return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\r\n};\r\nexport default VectorTile;\r\n"],"names":["const","super","let"],"mappings":"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"}