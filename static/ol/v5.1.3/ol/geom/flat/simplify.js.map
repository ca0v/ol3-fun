{"version":3,"file":"simplify.js","sources":["../../../../src/ol/geom/flat/simplify.js"],"sourcesContent":["/**\r\n * @module ol/geom/flat/simplify\r\n */\r\n// Based on simplify-js https://github.com/mourner/simplify-js\r\n// Copyright (c) 2012, Vladimir Agafonkin\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//\r\n//    1. Redistributions of source code must retain the above copyright notice,\r\n//       this list of conditions and the following disclaimer.\r\n//\r\n//    2. Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n// POSSIBILITY OF SUCH DAMAGE.\r\n\r\nimport {squaredSegmentDistance, squaredDistance} from '../../math.js';\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {boolean} highQuality Highest quality.\r\n * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @return {Array.<number>} Simplified line string.\r\n */\r\nexport function simplifyLineString(flatCoordinates, offset, end,\r\n  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\r\n  const simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\r\n    opt_simplifiedFlatCoordinates : [];\r\n  if (!highQuality) {\r\n    end = radialDistance(flatCoordinates, offset, end,\r\n      stride, squaredTolerance,\r\n      simplifiedFlatCoordinates, 0);\r\n    flatCoordinates = simplifiedFlatCoordinates;\r\n    offset = 0;\r\n    stride = 2;\r\n  }\r\n  simplifiedFlatCoordinates.length = douglasPeucker(\r\n    flatCoordinates, offset, end, stride, squaredTolerance,\r\n    simplifiedFlatCoordinates, 0);\r\n  return simplifiedFlatCoordinates;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeucker(flatCoordinates, offset, end,\r\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\r\n  const n = (end - offset) / stride;\r\n  if (n < 3) {\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n          flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n          flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  /** @type {Array.<number>} */\r\n  const markers = new Array(n);\r\n  markers[0] = 1;\r\n  markers[n - 1] = 1;\r\n  /** @type {Array.<number>} */\r\n  const stack = [offset, end - stride];\r\n  let index = 0;\r\n  while (stack.length > 0) {\r\n    const last = stack.pop();\r\n    const first = stack.pop();\r\n    let maxSquaredDistance = 0;\r\n    const x1 = flatCoordinates[first];\r\n    const y1 = flatCoordinates[first + 1];\r\n    const x2 = flatCoordinates[last];\r\n    const y2 = flatCoordinates[last + 1];\r\n    for (let i = first + stride; i < last; i += stride) {\r\n      const x = flatCoordinates[i];\r\n      const y = flatCoordinates[i + 1];\r\n      const squaredDistance = squaredSegmentDistance(\r\n        x, y, x1, y1, x2, y2);\r\n      if (squaredDistance > maxSquaredDistance) {\r\n        index = i;\r\n        maxSquaredDistance = squaredDistance;\r\n      }\r\n    }\r\n    if (maxSquaredDistance > squaredTolerance) {\r\n      markers[(index - offset) / stride] = 1;\r\n      if (first + stride < index) {\r\n        stack.push(first, index);\r\n      }\r\n      if (index + stride < last) {\r\n        stack.push(index, last);\r\n      }\r\n    }\r\n  }\r\n  for (let i = 0; i < n; ++i) {\r\n    if (markers[i]) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n          flatCoordinates[offset + i * stride];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n          flatCoordinates[offset + i * stride + 1];\r\n    }\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array.<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerArray(flatCoordinates, offset,\r\n  ends, stride, squaredTolerance, simplifiedFlatCoordinates,\r\n  simplifiedOffset, simplifiedEnds) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = douglasPeucker(\r\n      flatCoordinates, offset, end, stride, squaredTolerance,\r\n      simplifiedFlatCoordinates, simplifiedOffset);\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<Array.<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerMultiArray(\r\n  flatCoordinates, offset, endss, stride, squaredTolerance,\r\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = douglasPeuckerArray(\r\n      flatCoordinates, offset, ends, stride, squaredTolerance,\r\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function radialDistance(flatCoordinates, offset, end,\r\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\r\n  if (end <= offset + stride) {\r\n    // zero or one point, no simplification possible, so copy and return\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n          flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  // copy first point\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  let x2 = x1;\r\n  let y2 = y1;\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    x2 = flatCoordinates[offset];\r\n    y2 = flatCoordinates[offset + 1];\r\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\r\n      // copy point at offset\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  if (x2 != x1 || y2 != y1) {\r\n    // copy last point\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n\r\n/**\r\n * @param {number} value Value.\r\n * @param {number} tolerance Tolerance.\r\n * @return {number} Rounded value.\r\n */\r\nexport function snap(value, tolerance) {\r\n  return tolerance * Math.round(value / tolerance);\r\n}\r\n\r\n\r\n/**\r\n * Simplifies a line string using an algorithm designed by Tim Schaub.\r\n * Coordinates are snapped to the nearest value in a virtual grid and\r\n * consecutive duplicate coordinates are discarded.  This effectively preserves\r\n * topology as the simplification of any subsection of a line string is\r\n * independent of the rest of the line string.  This means that, for examples,\r\n * the common edge between two polygons will be simplified to the same line\r\n * string independently in both polygons.  This implementation uses a single\r\n * pass over the coordinates and eliminates intermediate collinear points.\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantize(flatCoordinates, offset, end, stride,\r\n  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\r\n  // do nothing if the line is empty\r\n  if (offset == end) {\r\n    return simplifiedOffset;\r\n  }\r\n  // snap the first coordinate (P1)\r\n  let x1 = snap(flatCoordinates[offset], tolerance);\r\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\r\n  offset += stride;\r\n  // add the first coordinate to the output\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  // find the next coordinate that does not snap to the same value as the first\r\n  // coordinate (P2)\r\n  let x2, y2;\r\n  do {\r\n    x2 = snap(flatCoordinates[offset], tolerance);\r\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    if (offset == end) {\r\n      // all coordinates snap to the same value, the line collapses to a point\r\n      // push the last snapped value anyway to ensure that the output contains\r\n      // at least two points\r\n      // FIXME should we really return at least two points anyway?\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      return simplifiedOffset;\r\n    }\r\n  } while (x2 == x1 && y2 == y1);\r\n  while (offset < end) {\r\n    // snap the next coordinate (P3)\r\n    const x3 = snap(flatCoordinates[offset], tolerance);\r\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    // skip P3 if it is equal to P2\r\n    if (x3 == x2 && y3 == y2) {\r\n      continue;\r\n    }\r\n    // calculate the delta between P1 and P2\r\n    const dx1 = x2 - x1;\r\n    const dy1 = y2 - y1;\r\n    // calculate the delta between P3 and P1\r\n    const dx2 = x3 - x1;\r\n    const dy2 = y3 - y1;\r\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\r\n    // P1 in the same direction then P2 is on the straight line between P1 and\r\n    // P3\r\n    if ((dx1 * dy2 == dy1 * dx2) &&\r\n        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\r\n        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\r\n      // discard P2 and set P2 = P3\r\n      x2 = x3;\r\n      y2 = y3;\r\n      continue;\r\n    }\r\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\r\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\r\n    // and continue with P1 = P2 and P2 = P3\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n    x1 = x2;\r\n    y1 = y2;\r\n    x2 = x3;\r\n    y2 = y3;\r\n  }\r\n  // add the last point (P2)\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  return simplifiedOffset;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array.<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeArray(\r\n  flatCoordinates, offset, ends, stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = quantize(\r\n      flatCoordinates, offset, end, stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates, simplifiedOffset);\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<Array.<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeMultiArray(\r\n  flatCoordinates, offset, endss, stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = quantizeArray(\r\n      flatCoordinates, offset, ends, stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n"],"names":["const","i","let"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,QAAQ,sBAAsB,EAAE,eAAe,OAAO,eAAe,CAAC;;;;;;;;;;;;;;AActE,OAAO,SAAS,kBAAkB,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG;EAC7D,MAAM,EAAE,gBAAgB,EAAE,WAAW,EAAE,6BAA6B,EAAE;EACtEA,GAAK,CAAC,yBAAyB,GAAG,6BAA6B,KAAK,SAAS;IAC3E,6BAA6B,GAAG,EAAE,CAAC;EACrC,IAAI,CAAC,WAAW,EAAE;IAChB,GAAG,GAAG,cAAc,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG;MAC/C,MAAM,EAAE,gBAAgB;MACxB,yBAAyB,EAAE,CAAC,CAAC,CAAC;IAChC,eAAe,GAAG,yBAAyB,CAAC;IAC5C,MAAM,GAAG,CAAC,CAAC;IACX,MAAM,GAAG,CAAC,CAAC;GACZ;EACD,yBAAyB,CAAC,MAAM,GAAG,cAAc;IAC/C,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,gBAAgB;IACtD,yBAAyB,EAAE,CAAC,CAAC,CAAC;EAChC,OAAO,yBAAyB,CAAC;CAClC;;;;;;;;;;;;;;AAcD,OAAO,SAAS,cAAc,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG;EACzD,MAAM,EAAE,gBAAgB,EAAE,yBAAyB,EAAE,gBAAgB,EAAE;EACvEA,GAAK,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC;EAClC,IAAI,CAAC,GAAG,CAAC,EAAE;IACT,OAAO,MAAM,GAAG,GAAG,EAAE,MAAM,IAAI,MAAM,EAAE;MACrC,yBAAyB,CAAC,gBAAgB,EAAE,CAAC;UACzC,eAAe,CAAC,MAAM,CAAC,CAAC;MAC5B,yBAAyB,CAAC,gBAAgB,EAAE,CAAC;UACzC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KACjC;IACD,OAAO,gBAAgB,CAAC;GACzB;;EAEDA,GAAK,CAAC,OAAO,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7B,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACf,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;;EAEnBA,GAAK,CAAC,KAAK,GAAG,CAAC,MAAM,EAAE,GAAG,GAAG,MAAM,CAAC,CAAC;EACrCE,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC;EACd,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;IACvBF,GAAK,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;IACzBA,GAAK,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;IAC1BE,GAAG,CAAC,kBAAkB,GAAG,CAAC,CAAC;IAC3BF,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC;IAClCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;IACtCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;IACjCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IACrC,KAAKE,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,MAAM,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,MAAM,EAAE;MAClDF,GAAK,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;MAC7BA,GAAK,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;MACjCA,GAAK,CAAC,eAAe,GAAG,sBAAsB;QAC5C,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;MACxB,IAAI,eAAe,GAAG,kBAAkB,EAAE;QACxC,KAAK,GAAG,CAAC,CAAC;QACV,kBAAkB,GAAG,eAAe,CAAC;OACtC;KACF;IACD,IAAI,kBAAkB,GAAG,gBAAgB,EAAE;MACzC,OAAO,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;MACvC,IAAI,KAAK,GAAG,MAAM,GAAG,KAAK,EAAE;QAC1B,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;OAC1B;MACD,IAAI,KAAK,GAAG,MAAM,GAAG,IAAI,EAAE;QACzB,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;OACzB;KACF;GACF;EACD,KAAKE,GAAG,CAACD,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG,CAAC,EAAE,EAAEA,GAAC,EAAE;IAC1B,IAAI,OAAO,CAACA,GAAC,CAAC,EAAE;MACd,yBAAyB,CAAC,gBAAgB,EAAE,CAAC;UACzC,eAAe,CAAC,MAAM,GAAGA,GAAC,GAAG,MAAM,CAAC,CAAC;MACzC,yBAAyB,CAAC,gBAAgB,EAAE,CAAC;UACzC,eAAe,CAAC,MAAM,GAAGA,GAAC,GAAG,MAAM,GAAG,CAAC,CAAC,CAAC;KAC9C;GACF;EACD,OAAO,gBAAgB,CAAC;CACzB;;;;;;;;;;;;;;;AAeD,OAAO,SAAS,mBAAmB,CAAC,eAAe,EAAE,MAAM;EACzD,IAAI,EAAE,MAAM,EAAE,gBAAgB,EAAE,yBAAyB;EACzD,gBAAgB,EAAE,cAAc,EAAE;EAClC,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC7CF,GAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,gBAAgB,GAAG,cAAc;MAC/B,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,gBAAgB;MACtD,yBAAyB,EAAE,gBAAgB,CAAC,CAAC;IAC/C,cAAc,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACtC,MAAM,GAAG,GAAG,CAAC;GACd;EACD,OAAO,gBAAgB,CAAC;CACzB;;;;;;;;;;;;;;;AAeD,OAAO,SAAS,wBAAwB;EACtC,eAAe,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,gBAAgB;EACxD,yBAAyB,EAAE,gBAAgB,EAAE,eAAe,EAAE;EAC9D,KAAKE,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC9CF,GAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtBA,GAAK,CAAC,cAAc,GAAG,EAAE,CAAC;IAC1B,gBAAgB,GAAG,mBAAmB;MACpC,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,gBAAgB;MACvD,yBAAyB,EAAE,gBAAgB,EAAE,cAAc,CAAC,CAAC;IAC/D,eAAe,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACrC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;GAChC;EACD,OAAO,gBAAgB,CAAC;CACzB;;;;;;;;;;;;;;AAcD,OAAO,SAAS,cAAc,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG;EACzD,MAAM,EAAE,gBAAgB,EAAE,yBAAyB,EAAE,gBAAgB,EAAE;EACvE,IAAI,GAAG,IAAI,MAAM,GAAG,MAAM,EAAE;;IAE1B,OAAO,MAAM,GAAG,GAAG,EAAE,MAAM,IAAI,MAAM,EAAE;MACrC,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;MACxE,yBAAyB,CAAC,gBAAgB,EAAE,CAAC;UACzC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KACjC;IACD,OAAO,gBAAgB,CAAC;GACzB;EACDE,GAAG,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;EACjCA,GAAG,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;;EAErC,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;EACnD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;EACnDA,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC;EACZA,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC;EACZ,KAAK,MAAM,IAAI,MAAM,EAAE,MAAM,GAAG,GAAG,EAAE,MAAM,IAAI,MAAM,EAAE;IACrD,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;IAC7B,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACjC,IAAI,eAAe,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAG,gBAAgB,EAAE;;MAEtD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;MACnD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;MACnD,EAAE,GAAG,EAAE,CAAC;MACR,EAAE,GAAG,EAAE,CAAC;KACT;GACF;EACD,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;;IAExB,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;IACnD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;GACpD;EACD,OAAO,gBAAgB,CAAC;CACzB;;;;;;;;AAQD,OAAO,SAAS,IAAI,CAAC,KAAK,EAAE,SAAS,EAAE;EACrC,OAAO,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC;CAClD;;;;;;;;;;;;;;;;;;;;;;AAsBD,OAAO,SAAS,QAAQ,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM;EAC3D,SAAS,EAAE,yBAAyB,EAAE,gBAAgB,EAAE;;EAExD,IAAI,MAAM,IAAI,GAAG,EAAE;IACjB,OAAO,gBAAgB,CAAC;GACzB;;EAEDA,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,SAAS,CAAC,CAAC;EAClDA,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;EACtD,MAAM,IAAI,MAAM,CAAC;;EAEjB,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;EACnD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;;;EAGnDA,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;EACX,GAAG;IACD,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,SAAS,CAAC,CAAC;IAC9C,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;IAClD,MAAM,IAAI,MAAM,CAAC;IACjB,IAAI,MAAM,IAAI,GAAG,EAAE;;;;;MAKjB,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;MACnD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;MACnD,OAAO,gBAAgB,CAAC;KACzB;GACF,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;EAC/B,OAAO,MAAM,GAAG,GAAG,EAAE;;IAEnBF,GAAK,CAAC,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,SAAS,CAAC,CAAC;IACpDA,GAAK,CAAC,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;IACxD,MAAM,IAAI,MAAM,CAAC;;IAEjB,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;MACxB,SAAS;KACV;;IAEDA,GAAK,CAAC,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;IACpBA,GAAK,CAAC,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;;IAEpBA,GAAK,CAAC,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;IACpBA,GAAK,CAAC,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;;;;IAIpB,IAAI,CAAC,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,CAAC;QACxB,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC;QAChE,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,EAAE;;MAEpE,EAAE,GAAG,EAAE,CAAC;MACR,EAAE,GAAG,EAAE,CAAC;MACR,SAAS;KACV;;;;IAID,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;IACnD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;IACnD,EAAE,GAAG,EAAE,CAAC;IACR,EAAE,GAAG,EAAE,CAAC;IACR,EAAE,GAAG,EAAE,CAAC;IACR,EAAE,GAAG,EAAE,CAAC;GACT;;EAED,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;EACnD,yBAAyB,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,CAAC;EACnD,OAAO,gBAAgB,CAAC;CACzB;;;;;;;;;;;;;;;AAeD,OAAO,SAAS,aAAa;EAC3B,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM;EACrC,SAAS;EACT,yBAAyB,EAAE,gBAAgB,EAAE,cAAc,EAAE;EAC7D,KAAKE,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC7CF,GAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,gBAAgB,GAAG,QAAQ;MACzB,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM;MACpC,SAAS;MACT,yBAAyB,EAAE,gBAAgB,CAAC,CAAC;IAC/C,cAAc,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACtC,MAAM,GAAG,GAAG,CAAC;GACd;EACD,OAAO,gBAAgB,CAAC;CACzB;;;;;;;;;;;;;;;AAeD,OAAO,SAAS,kBAAkB;EAChC,eAAe,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;EACtC,SAAS;EACT,yBAAyB,EAAE,gBAAgB,EAAE,eAAe,EAAE;EAC9D,KAAKE,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC9CF,GAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtBA,GAAK,CAAC,cAAc,GAAG,EAAE,CAAC;IAC1B,gBAAgB,GAAG,aAAa;MAC9B,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM;MACrC,SAAS;MACT,yBAAyB,EAAE,gBAAgB,EAAE,cAAc,CAAC,CAAC;IAC/D,eAAe,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACrC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;GAChC;EACD,OAAO,gBAAgB,CAAC;CACzB;"}