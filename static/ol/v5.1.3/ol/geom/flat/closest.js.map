{"version":3,"file":"closest.js","sources":["../../../../src/ol/geom/flat/closest.js"],"sourcesContent":["/**\r\n * @module ol/geom/flat/closest\r\n */\r\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\r\n\r\n\r\n/**\r\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\r\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\r\n * dimensions are linearly interpolated.\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset1 Offset 1.\r\n * @param {number} offset2 Offset 2.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array.<number>} closestPoint Closest point.\r\n */\r\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\r\n  const x1 = flatCoordinates[offset1];\r\n  const y1 = flatCoordinates[offset1 + 1];\r\n  const dx = flatCoordinates[offset2] - x1;\r\n  const dy = flatCoordinates[offset2 + 1] - y1;\r\n  let offset;\r\n  if (dx === 0 && dy === 0) {\r\n    offset = offset1;\r\n  } else {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      offset = offset2;\r\n    } else if (t > 0) {\r\n      for (let i = 0; i < stride; ++i) {\r\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i],\r\n          flatCoordinates[offset2 + i], t);\r\n      }\r\n      closestPoint.length = stride;\r\n      return;\r\n    } else {\r\n      offset = offset1;\r\n    }\r\n  }\r\n  for (let i = 0; i < stride; ++i) {\r\n    closestPoint[i] = flatCoordinates[offset + i];\r\n  }\r\n  closestPoint.length = stride;\r\n}\r\n\r\n\r\n/**\r\n * Return the squared of the largest distance between any pair of consecutive\r\n * coordinates.\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\r\n    if (squaredDelta > max) {\r\n      max = squaredDelta;\r\n    }\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return max;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    max = maxSquaredDelta(\r\n      flatCoordinates, offset, end, stride, max);\r\n    offset = end;\r\n  }\r\n  return max;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<Array.<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    max = arrayMaxSquaredDelta(\r\n      flatCoordinates, offset, ends, stride, max);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return max;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array.<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestPoint(flatCoordinates, offset, end,\r\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\r\n  opt_tmpPoint) {\r\n  if (offset == end) {\r\n    return minSquaredDistance;\r\n  }\r\n  let i, squaredDistance;\r\n  if (maxDelta === 0) {\r\n    // All points are identical, so just test the first point.\r\n    squaredDistance = squaredDx(\r\n      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = flatCoordinates[offset + i];\r\n      }\r\n      closestPoint.length = stride;\r\n      return squaredDistance;\r\n    } else {\r\n      return minSquaredDistance;\r\n    }\r\n  }\r\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\r\n  let index = offset + stride;\r\n  while (index < end) {\r\n    assignClosest(\r\n      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n      index += stride;\r\n    } else {\r\n      // Skip ahead multiple points, because we know that all the skipped\r\n      // points cannot be any closer than the closest point we have found so\r\n      // far.  We know this because we know how close the current point is, how\r\n      // close the closest point we have found so far is, and the maximum\r\n      // distance between consecutive points.  For example, if we're currently\r\n      // at distance 10, the best we've found so far is 3, and that the maximum\r\n      // distance between consecutive points is 2, then we'll need to skip at\r\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\r\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\r\n      // always advance at least one point, to avoid an infinite loop.\r\n      index += stride * Math.max(\r\n        ((Math.sqrt(squaredDistance) -\r\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\r\n    }\r\n  }\r\n  if (isRing) {\r\n    // Check the closing segment.\r\n    assignClosest(\r\n      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n    }\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array.<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends,\r\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\r\n  opt_tmpPoint) {\r\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    minSquaredDistance = assignClosestPoint(\r\n      flatCoordinates, offset, end, stride,\r\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\r\n    offset = end;\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array.<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array.<Array.<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array.<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset,\r\n  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\r\n  opt_tmpPoint) {\r\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    minSquaredDistance = assignClosestArrayPoint(\r\n      flatCoordinates, offset, ends, stride,\r\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n"],"names":["i","const","let"],"mappings":"AAAA;;;AAGA,QAAQ,IAAI,EAAE,eAAe,IAAI,SAAS,OAAO,eAAe,CAAC;;;;;;;;;;;;;;;AAejE,SAAS,aAAa,CAAC,eAAe,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE;EACpFC,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,CAAC,CAAC;EACpCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;EACxCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;EACzCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;EAC7CC,GAAG,CAAC,MAAM,CAAC;EACX,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;IACxB,MAAM,GAAG,OAAO,CAAC;GAClB,MAAM;IACLD,GAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;IAChE,IAAI,CAAC,GAAG,CAAC,EAAE;MACT,MAAM,GAAG,OAAO,CAAC;KAClB,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE;MAChB,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC/B,YAAY,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC;UACjD,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;OACpC;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;MAC7B,OAAO;KACR,MAAM;MACL,MAAM,GAAG,OAAO,CAAC;KAClB;GACF;EACD,KAAKA,GAAG,CAACF,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG,MAAM,EAAE,EAAEA,GAAC,EAAE;IAC/B,YAAY,CAACA,GAAC,CAAC,GAAG,eAAe,CAAC,MAAM,GAAGA,GAAC,CAAC,CAAC;GAC/C;EACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;CAC9B;;;;;;;;;;;;;AAaD,OAAO,SAAS,eAAe,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE;EACzEE,GAAG,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;EACjCA,GAAG,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;EACrC,KAAK,MAAM,IAAI,MAAM,EAAE,MAAM,GAAG,GAAG,EAAE,MAAM,IAAI,MAAM,EAAE;IACrDD,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;IACnCA,GAAK,CAAC,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvCA,GAAK,CAAC,YAAY,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC/C,IAAI,YAAY,GAAG,GAAG,EAAE;MACtB,GAAG,GAAG,YAAY,CAAC;KACpB;IACD,EAAE,GAAG,EAAE,CAAC;IACR,EAAE,GAAG,EAAE,CAAC;GACT;EACD,OAAO,GAAG,CAAC;CACZ;;;;;;;;;;;AAWD,OAAO,SAAS,oBAAoB,CAAC,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE;EAC/E,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC7CD,GAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,GAAG,GAAG,eAAe;MACnB,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IAC7C,MAAM,GAAG,GAAG,CAAC;GACd;EACD,OAAO,GAAG,CAAC;CACZ;;;;;;;;;;;AAWD,OAAO,SAAS,yBAAyB,CAAC,eAAe,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,EAAE;EACrF,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC9CD,GAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtB,GAAG,GAAG,oBAAoB;MACxB,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IAC9C,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;GAChC;EACD,OAAO,GAAG,CAAC;CACZ;;;;;;;;;;;;;;;;;AAiBD,OAAO,SAAS,kBAAkB,CAAC,eAAe,EAAE,MAAM,EAAE,GAAG;EAC7D,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB;EAChE,YAAY,EAAE;EACd,IAAI,MAAM,IAAI,GAAG,EAAE;IACjB,OAAO,kBAAkB,CAAC;GAC3B;EACDC,GAAG,CAAC,CAAC,EAAE,eAAe,CAAC;EACvB,IAAI,QAAQ,KAAK,CAAC,EAAE;;IAElB,eAAe,GAAG,SAAS;MACzB,CAAC,EAAE,CAAC,EAAE,eAAe,CAAC,MAAM,CAAC,EAAE,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC9D,IAAI,eAAe,GAAG,kBAAkB,EAAE;MACxC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC3B,YAAY,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;OAC/C;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;MAC7B,OAAO,eAAe,CAAC;KACxB,MAAM;MACL,OAAO,kBAAkB,CAAC;KAC3B;GACF;EACDD,GAAK,CAAC,QAAQ,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC1DC,GAAG,CAAC,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;EAC5B,OAAO,KAAK,GAAG,GAAG,EAAE;IAClB,aAAa;MACX,eAAe,EAAE,KAAK,GAAG,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;IAClE,eAAe,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5D,IAAI,eAAe,GAAG,kBAAkB,EAAE;MACxC,kBAAkB,GAAG,eAAe,CAAC;MACrC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC3B,YAAY,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;OAC/B;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;MAC7B,KAAK,IAAI,MAAM,CAAC;KACjB,MAAM;;;;;;;;;;;MAWL,KAAK,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG;QACxB,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC;YACxB,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;KAC1D;GACF;EACD,IAAI,MAAM,EAAE;;IAEV,aAAa;MACX,eAAe,EAAE,GAAG,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;IACjE,eAAe,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5D,IAAI,eAAe,GAAG,kBAAkB,EAAE;MACxC,kBAAkB,GAAG,eAAe,CAAC;MACrC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC3B,YAAY,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;OAC/B;MACD,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;KAC9B;GACF;EACD,OAAO,kBAAkB,CAAC;CAC3B;;;;;;;;;;;;;;;;;AAiBD,OAAO,SAAS,uBAAuB,CAAC,eAAe,EAAE,MAAM,EAAE,IAAI;EACnE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB;EAChE,YAAY,EAAE;EACdD,GAAK,CAAC,QAAQ,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC1D,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC7CD,GAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,kBAAkB,GAAG,kBAAkB;MACrC,eAAe,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM;MACpC,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;IACtE,MAAM,GAAG,GAAG,CAAC;GACd;EACD,OAAO,kBAAkB,CAAC;CAC3B;;;;;;;;;;;;;;;;;AAiBD,OAAO,SAAS,4BAA4B,CAAC,eAAe,EAAE,MAAM;EAClE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB;EACvE,YAAY,EAAE;EACdA,GAAK,CAAC,QAAQ,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAC1D,KAAKC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;IAC9CD,GAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtB,kBAAkB,GAAG,uBAAuB;MAC1C,eAAe,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM;MACrC,QAAQ,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;IACtE,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;GAChC;EACD,OAAO,kBAAkB,CAAC;CAC3B;"}